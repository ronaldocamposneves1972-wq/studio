/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data and role-based access control for shared resources,
 *              allowing for secure management of users, clients, products, sales, and financial data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Accessible only by the user and admins.
 * - /users/{userId}/sales/{saleId}: Stores sales data associated with a specific user. Accessible only by the user and admins.
 * - /clients/{clientId}: Stores client information. Accessible by users with appropriate roles (Admin, Gestor, Atendente).
 * - /products/{productId}: Stores product information. Accessible by users with appropriate roles (Admin, Gestor).
 * - /banks/{bankId}: Stores bank information. Accessible by users with appropriate roles (Admin, Gestor, Financeiro).
 * - /quizzes/{quizId}: Stores quiz configurations. Accessible by users with appropriate roles (Admin, Gestor).
 * - /webhooks/{webhookId}: Stores webhook configurations. Accessible by users with Admin role.
 * - /roles_admin/{userId}: Documents in this collection indicate admin status. Existence implies admin role.
 * - /accounts/{accountId}: Stores bank and digital account information.
 * - /transactions/{transactionId}: Stores all financial transactions.
 * - /payablesReceivables/{prId}: Stores accounts payable and receivable items.
 *
 * Key Security Decisions:
 * - User-owned data is strictly controlled, allowing only the user and admins to access it.
 * - Role-based access control is used for shared resources like clients, products, and banks.
 * - Listing user documents is forbidden to prevent enumeration.
 * - The `roles_admin` collection is used to efficiently check admin status.
 *
 * Denormalization for Authorization:
 * - Admin status is checked via the existence of a document in `/roles_admin/{userId}`, avoiding complex queries or custom claims.
 *   For roles other than admin, the User document itself should contain role information to avoid additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user profile data. Admins can also read and write user data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own profile: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their profile: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their profile: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' can delete their profile: request.auth.uid == 'user123'
     * @allow (get) Admin can read user with ID 'user123' profile. Document exists in /roles_admin/user123
     * @deny (create) User with ID 'user456' tries to create profile for 'user123': request.auth.uid != 'user123'
     * @deny (get) User with ID 'user456' tries to read profile of 'user123': request.auth.uid != 'user123' and is not admin.
     * @principle Enforces document ownership for writes, allows owner and admins full read/write.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if false; // Listing users is not permitted.

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && (isOwner(userId) && resource != null && request.resource.data.id == resource.data.id) || isAdmin();
      allow delete: if isSignedIn() && (isExistingOwner(userId) || isAdmin());
    }

    /**
     * @description Allows a user to read, create, update, and delete sales data associated with their user ID. Admins can also manage all sales data.
     * @path /users/{userId}/sales/{saleId}
     * @allow (create) User with ID 'user123' can create a sale under their ID: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read a sale under their ID: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update a sale under their ID: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' can delete a sale under their ID: request.auth.uid == 'user123'
     * @allow (get) Admin can read sale with ID 'sale456' that belongs to user with ID 'user123'. Document exists in /roles_admin/user123
     * @deny (create) User with ID 'user456' tries to create a sale under user 'user123': request.auth.uid != 'user123'
     * @deny (get) User with ID 'user456' tries to read a sale under user 'user123': request.auth.uid != 'user123' and is not admin.
     * @principle Enforces document ownership for writes, allows owner and admins full read/write.
     */
    match /users/{userId}/sales/{saleId} {
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && (isOwner(userId) && resource != null) || isAdmin();
      allow delete: if isSignedIn() && (isExistingOwner(userId) || isAdmin());
    }

    /**
     * @description Allows users with 'Admin', 'Gestor', or 'Atendente' roles to read, create, update, and delete client data.
     * @path /clients/{clientId}
     * @allow (create) User with 'Admin' role can create a client: isAdmin()
     * @allow (get) User with 'Gestor' role can read a client: isGestor()
     * @allow (update) User with 'Atendente' role can update a client: isAtendente()
     * @allow (delete) User with 'Admin' role can delete a client: isAdmin()
     * @deny (create) User with no role tries to create a client: !isAdmin() && !isGestor() && !isAtendente()
     * @deny (get) User with no role tries to read a client: !isAdmin() && !isGestor() && !isAtendente()
     * @principle Enforces role-based access control for client data.
     */
    match /clients/{clientId} {
      allow get: if isSignedIn() && (isAdmin() || isGestor() || isAtendente());
      allow list: if isSignedIn() && (isAdmin() || isGestor() || isAtendente());

      allow create: if isSignedIn() && (isAdmin() || isGestor() || isAtendente());
      allow update: if isSignedIn() && (isAdmin() || isGestor() || isAtendente() && resource != null);
      allow delete: if isSignedIn() && (isAdmin() && resource != null);
    }

    /**
     * @description Allows users with 'Admin' or 'Gestor' roles to read, create, update, and delete product data.
     * @path /products/{productId}
     * @allow (create) User with 'Admin' role can create a product: isAdmin()
     * @allow (get) User with 'Gestor' role can read a product: isGestor()
     * @allow (update) User with 'Admin' role can update a product: isAdmin()
     * @allow (delete) User with 'Gestor' role can delete a product: isGestor()
     * @deny (create) User with no role tries to create a product: !isAdmin() && !isGestor()
     * @deny (get) User with no role tries to read a product: !isAdmin() && !isGestor()
     * @principle Enforces role-based access control for product data.
     */
    match /products/{productId} {
      allow get: if isSignedIn() && (isAdmin() || isGestor());
      allow list: if isSignedIn() && (isAdmin() || isGestor());

      allow create: if isSignedIn() && (isAdmin() || isGestor());
      allow update: if isSignedIn() && ((isAdmin() || isGestor()) && resource != null);
      allow delete: if isSignedIn() && ((isAdmin() || isGestor()) && resource != null);
    }

    /**
     * @description Allows users with 'Admin', 'Gestor', or 'Financeiro' roles to read, create, update, and delete bank data.
     * @path /banks/{bankId}
     * @allow (create) User with 'Admin' role can create a bank: isAdmin()
     * @allow (get) User with 'Gestor' role can read a bank: isGestor()
     * @allow (update) User with 'Financeiro' role can update a bank: isFinanceiro()
     * @allow (delete) User with 'Admin' role can delete a bank: isAdmin()
     * @deny (create) User with no role tries to create a bank: !isAdmin() && !isGestor() && !isFinanceiro()
     * @deny (get) User with no role tries to read a bank: !isAdmin() && !isGestor() && !isFinanceiro()
     * @principle Enforces role-based access control for bank data.
     */
    match /banks/{bankId} {
      allow get: if isSignedIn() && (isAdmin() || isGestor() || isFinanceiro());
      allow list: if isSignedIn() && (isAdmin() || isGestor() || isFinanceiro());

      allow create: if isSignedIn() && (isAdmin() || isGestor() || isFinanceiro());
      allow update: if isSignedIn() && ((isAdmin() || isGestor() || isFinanceiro()) && resource != null);
      allow delete: if isSignedIn() && (isAdmin() && resource != null);
    }

    /**
     * @description Allows users with 'Admin' or 'Gestor' roles to read, create, update, and delete quiz data.
     * @path /quizzes/{quizId}
     * @allow (create) User with 'Admin' role can create a quiz: isAdmin()
     * @allow (get) User with 'Gestor' role can read a quiz: isGestor()
     * @allow (update) User with 'Admin' role can update a quiz: isAdmin()
     * @allow (delete) User with 'Gestor' role can delete a quiz: isGestor()
     * @deny (create) User with no role tries to create a quiz: !isAdmin() && !isGestor()
     * @deny (get) User with no role tries to read a quiz: !isAdmin() && !isGestor()
     * @principle Enforces role-based access control for quiz data.
     */
    match /quizzes/{quizId} {
      allow get: if isSignedIn() && (isAdmin() || isGestor());
      allow list: if isSignedIn() && (isAdmin() || isGestor());

      allow create: if isSignedIn() && (isAdmin() || isGestor());
      allow update: if isSignedIn() && ((isAdmin() || isGestor()) && resource != null);
      allow delete: if isSignedIn() && ((isAdmin() || isGestor()) && resource != null);
    }

    /**
     * @description Allows users with 'Admin' role to read, create, update, and delete webhook data.
     * @path /webhooks/{webhookId}
     * @allow (create) User with 'Admin' role can create a webhook: isAdmin()
     * @allow (get) User with 'Admin' role can read a webhook: isAdmin()
     * @allow (update) User with 'Admin' role can update a webhook: isAdmin()
     * @allow (delete) User with 'Admin' role can delete a webhook: isAdmin()
     * @deny (create) User with no role tries to create a webhook: !isAdmin()
     * @deny (get) User with no role tries to read a webhook: !isAdmin()
     * @principle Enforces role-based access control for webhook data, accessible only to admins.
     */
    match /webhooks/{webhookId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();

      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && (isAdmin() && resource != null);
      allow delete: if isSignedIn() && (isAdmin() && resource != null);
    }

    /**
     * @description Allows only admins to read, create, update, and delete documents indicating admin status.
     * @path /roles_admin/{userId}
     * @allow (create) Admin can create a role: isAdmin()
     * @allow (get) Admin can read a role: isAdmin()
     * @allow (update) Admin can update a role: isAdmin()
     * @allow (delete) Admin can delete a role: isAdmin()
     * @deny (create) Non-admin tries to create a role: !isAdmin()
     * @deny (get) Non-admin tries to read a role: !isAdmin()
     * @principle  Collection to manage admin roles, only accessible by existing admins.
     */
    match /roles_admin/{userId} {
        allow get: if isSignedIn() && isAdmin();
        allow list: if false;

        allow create: if isSignedIn() && isAdmin();
        allow update: if isSignedIn() && (isAdmin() && resource != null);
        allow delete: if isSignedIn() && (isAdmin() && resource != null);
    }

    /**
     * @description Allows read, create, update, and delete operations on account documents.
     * @path /accounts/{accountId}
     * @allow (create) Any authenticated user can create an account.
     * @allow (get) Any authenticated user can read an account.
     * @allow (update) Any authenticated user can update an existing account.
     * @allow (delete) Any authenticated user can delete an existing account.
     * @principle Allows authenticated access to accounts.
     */
    match /accounts/{accountId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

     /**
      * @description Allows read, create, update, and delete operations on transaction documents.
      * @path /transactions/{transactionId}
      * @allow (create) Any authenticated user can create a transaction.
      * @allow (get) Any authenticated user can read a transaction.
      * @allow (update) Any authenticated user can update an existing transaction.
      * @allow (delete) Any authenticated user can delete an existing transaction.
      * @principle Allows authenticated access to transactions.
      */
    match /transactions/{transactionId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows read, create, update, and delete operations on payable/receivable documents.
     * @path /payablesReceivables/{prId}
     * @allow (create) Any authenticated user can create a payable/receivable item.
     * @allow (get) Any authenticated user can read a payable/receivable item.
     * @allow (update) Any authenticated user can update an existing payable/receivable item.
     * @allow (delete) Any authenticated user can delete an existing payable/receivable item.
     * @principle Allows authenticated access to payable/receivable items.
     */
    match /payablesReceivables/{prId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    // ---- Helper functions ----
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // TODO: Implement proper role checks. These are placeholders.
    function isGestor() {
      return true;
    }

    function isAtendente() {
      return true;
    }

    function isFinanceiro() {
      return true;
    }
  }
}