/**
 * @fileoverview Firestore Security Rules for ConsorciaTech application.
 *
 * Core Philosophy:
 * This ruleset prioritizes authorization independence by denormalizing data to avoid costly `get()` calls within rules. It enforces a strict ownership model for user-specific data and leverages path-based authorization where applicable. Public read access is granted to product catalogs, while write access is restricted.
 *
 * Data Structure:
 * - /users/{userId}: Stores personal user data, accessible only to the owning user.
 * - /roles_admin/{userId}: Document existence determines admin role; write access is denied.
 * - /clients/{clientId}: Stores client data, accessible to authenticated users for now, create, update and delete are open.
 * - /clients/{clientId}/documents/{documentId}: Stores client documents, only accessible to the specific client.
 * - /financial_institutions/{financialInstitutionId}: Stores financial institution data, accessible to all for read, but protected on writes.
 * - /consortiums/{consortiumId}: Stores consortium product data, publicly readable, but writes are forbidden.
 * - /credit_products/{creditProductId}: Stores credit product data, publicly readable, but writes are forbidden.
 * - /product_combos/{productComboId}: Stores product combo data, publicly readable, but writes are forbidden.
 * - /sales_proposals/{salesProposalId}: Stores sales proposal data, access restricted to the associated client (clientId on document).
 * - /commissions/{commissionId}: Stores commission data, accessible to all for read, but protected on writes.
 * - /quizzes/{quizId}: Stores quiz data, accessible to all for read, but protected on writes.
 * - /questions/{questionId}: Stores question data, accessible to all for read, but protected on writes.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied for privacy.
 * - Read-only collections (products) are made publicly readable.
 * - Admin roles are determined by document existence in /roles_admin/{userId}.
 * - Data validation is minimal during prototyping to allow for rapid schema iteration. Focus is on authorization.
 *
 * Denormalization for Authorization:
 * - SalesProposals contain a denormalized 'clientId' field to enable direct authorization without needing to query the /clients collection.
 *
 * Structural Segregation:
 * - Draft vs. Published content is not explicitly handled via structural segregation in this initial ruleset. Consider moving to separate collections as the application evolves.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the UIDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user owns the existing document based on userId.
     *              It also checks if the document exists.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the UIDs match and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return (isOwner(userId) && resource != null);
    }

    /**
     * @description Rule for user-specific data.
     * @path /users/{userId}
     * @allow (create) Signed-in user with matching UID creates their own document.
     * @allow (get, list, update, delete) Signed-in user with matching UID reads or modifies their own document.
     * @deny (create) Signed-in user attempts to create a document for another user.
     * @deny (get, list, update, delete) Signed-in user attempts to read or modify another user's document.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for admin role determination. Document existence in this collection grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (get) Signed-in user can check for their own admin role.
     * @deny (create, update, delete, list) No one can create, update, delete or list documents in this collection.
     * @principle Existence over Content. Authorization using /roles_admin/{uid}.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
      allow list: if false;
    }

    /**
     * @description Rule for client data.
     * @path /clients/{clientId}
     * @allow (get, list) Any signed-in user can read client data.
     * @allow (create, update, delete) Any signed-in user can create, update, and delete client data.
     * @principle Allows open read and write access to client data for prototyping.
     */
    match /clients/{clientId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Rule for client documents.
     * @path /clients/{clientId}/documents/{documentId}
     * @allow (create) Signed-in user creates a document for their own client ID.
     * @allow (get, list, update, delete) Signed-in user reads or modifies documents for their own client ID.
     * @deny (create) Signed-in user attempts to create a document for another client.
     * @deny (get, list, update, delete) Signed-in user attempts to read or modify another client's document.
     * @principle Enforces document ownership based on the client ID.
     */
    match /clients/{clientId}/documents/{documentId} {
      allow get, list: if isOwner(clientId);
      allow create: if isOwner(clientId);
      allow update: if isExistingOwner(clientId);
      allow delete: if isExistingOwner(clientId);
    }

    /**
     * @description Rule for financial institution data.
     * @path /financial_institutions/{financialInstitutionId}
     * @allow (get, list) Any user can read financial institution data.
     * @deny (create, update, delete) No one can create, update, or delete financial institution data.
     * @principle Allows public read access but restricts write access.
     */
    match /financial_institutions/{financialInstitutionId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for consortium product data.
     * @path /consortiums/{consortiumId}
     * @allow (get, list) Any user can read consortium product data.
     * @deny (create, update, delete) No one can create, update, or delete consortium product data.
     * @principle Allows public read access but restricts write access.
     */
    match /consortiums/{consortiumId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for credit product data.
     * @path /credit_products/{creditProductId}
     * @allow (get, list) Any user can read credit product data.
     * @deny (create, update, delete) No one can create, update, or delete credit product data.
     * @principle Allows public read access but restricts write access.
     */
    match /credit_products/{creditProductId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for product combo data.
     * @path /product_combos/{productComboId}
     * @allow (get, list) Any user can read product combo data.
     * @deny (create, update, delete) No one can create, update, or delete product combo data.
     * @principle Allows public read access but restricts write access.
     */
    match /product_combos/{productComboId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for sales proposal data. Access is granted to the client associated with the proposal.
     * @path /sales_proposals/{salesProposalId}
     * @allow (get, list) Signed-in user can read sales proposal data if they are the associated client.
     * @allow (create) Signed-in user can create sales proposal data if the clientId matches their own user ID.
     * @allow (update, delete) Signed-in user can update/delete sales proposal data if they are the associated client.
     * @deny (get, list, create, update, delete) Signed-in user attempts to access or modify a sales proposal not associated with their client ID.
     * @principle Enforces client-based access to sales proposals, leveraging denormalized clientId.
     */
    match /sales_proposals/{salesProposalId} {
      allow get, list: if request.auth.uid == resource.data.clientId;
      allow create: if request.resource.data.clientId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.clientId);
      allow delete: if isExistingOwner(resource.data.clientId);
    }

    /**
     * @description Rule for commission data.
     * @path /commissions/{commissionId}
     * @allow (get, list) Any user can read commission data.
     * @deny (create, update, delete) No one can create, update, or delete commission data.
     * @principle Allows public read access but restricts write access.
     */
    match /commissions/{commissionId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for quiz data.
     * @path /quizzes/{quizId}
     * @allow (get, list) Any user can read quiz data.
     * @deny (create, update, delete) No one can create, update, or delete quiz data.
     * @principle Allows public read access but restricts write access.
     */
    match /quizzes/{quizId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for question data.
     * @path /questions/{questionId}
     * @allow (get, list) Any user can read question data.
     * @deny (create, update, delete) No one can create, update, or delete question data.
     * @principle Allows public read access but restricts write access.
     */
    match /questions/{questionId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Rule for products data.
      * @path /products
      * @allow (list) Any user can read product data.
      * @deny (get, create, update, delete) No one can read, create, update, or delete product data.
      * @principle Allows public list access but restricts write access.
      */
     match /products {
      allow list: if true;
      allow get, create, update, delete: if false;
    }
  }
}