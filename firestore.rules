/**
 * @fileOverview Firestore Security Rules for a Consórcio and Crédito Management System.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data (e.g., sales),
 * role-based access for shared data (e.g., clients, products, banks), and admin-only access for
 * sensitive configurations (e.g., webhooks). Authorization Independence is maintained via path-based
 * ownership and denormalization (copying authorization data onto secured documents).
 * Structural Segregation ensures collections contain documents with similar security needs.
 *
 * Data Structure:
 * - /users/{userId}: User profile information. Only accessible by the user themselves.
 * - /users/{userId}/sales/{saleId}: Sales data owned by a specific user.
 * - /clients/{clientId}: Client information. Accessible based on user role (Admin, Gestor, Atendente).
 * - /products/{productId}: Product information. Accessible based on user role (Admin, Gestor).
 * - /banks/{bankId}: Bank information. Accessible based on user role (Admin, Gestor, Financeiro).
 * - /quizzes/{quizId}: Quiz configurations. Accessible based on user role (Admin, Gestor).
 * - /webhooks/{webhookId}: Webhook configurations. Accessible only by Admins.
 * - /roles_admin/{userId}: Documents indicating admin status. Presence grants admin role.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - `get` operations do not check for document existence.
 * - Timestamp fields are not validated for prototyping flexibility.
 * - Authorization relies on `request.auth` and avoids complex queries.
 *
 * Denormalization for Authorization:
 * - No explicit denormalization is performed in this prototype, but the rules are designed to
 *   accommodate denormalized role data in the future (e.g., a `managers` map on `Sale` documents
 *   to allow 'Gestor' roles access).
 *
 * Structural Segregation:
 * - User-specific data (sales) is stored under the /users/{userId} path, while shared data
 *   (clients, products, banks) resides in top-level collections. Webhooks are in a separate
 *   collection accessible only by admins.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure root access
     * @path /
     * @allow (get, list) if false;
     * @deny (create, update, delete) if true;
     * @principle Restrict root access
     */
    match /{document=**} {
      allow read, write: if false;
    }

    /**
     * @description Grants access to user profile information.
     * @path /users/{userId}
     * @allow (get, list) User can read their own profile.
     * @allow (create) User can create their own profile with matching id.
     * @allow (update,delete) User can update their own profile if it exists.
     * @deny (create) if request.auth.uid != request.resource.data.id; // Mismatched user ID on create.
     * @deny (update) User tries to change the id after creation.
     * @deny (delete) User tries to delete the document that does not exists
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && (request.resource.data.id == userId);
      allow update: if isSignedIn() && isExistingOwner(userId) && (request.resource.data.id == resource.data.id);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Grants access to sales data associated with a specific user.
     * @path /users/{userId}/sales/{saleId}
     * @allow (get, list) User can read their own sales data.
     * @allow (create, update,delete) User can create/update/delete their own sales data if it exists.
     * @deny (create) User attempts to create sales data for another user.
     * @deny (update) User attempts to modify sales data that does not exist.
     * @deny (delete) User attempts to delete sales data that does not exist.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/sales/{saleId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && (request.resource.data.salesRepId == userId);
      allow update: if isSignedIn() && isExistingOwner(userId) && (resource.data.salesRepId == userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Grants access to client information.
     * @path /clients/{clientId}
     * @allow (get, list) All users can read client information
     * @allow (create, update, delete) All users can create/update/delete client information.
     * @principle Open access for prototyping.
     */
    match /clients/{clientId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null);
      allow delete: if isSignedIn() && (resource != null);
    }

    /**
     * @description Grants access to product information.
     * @path /products/{productId}
     * @allow (get, list) All users can read product information
     * @allow (create, update, delete) All users can create/update/delete product information.
     * @principle Open access for prototyping.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null);
      allow delete: if isSignedIn() && (resource != null);
    }

    /**
     * @description Grants access to bank information.
     * @path /banks/{bankId}
     * @allow (get, list) All users can read bank information
     * @allow (create, update, delete) All users can create/update/delete bank information.
     * @principle Open access for prototyping.
     */
    match /banks/{bankId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null);
      allow delete: if isSignedIn() && (resource != null);
    }

    /**
     * @description Grants access to quiz configurations.
     * @path /quizzes/{quizId}
     * @allow (get, list) All users can read quiz configurations
     * @allow (create, update, delete) All users can create/update/delete quiz configurations.
     * @principle Open access for prototyping.
     */
    match /quizzes/{quizId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null);
      allow delete: if isSignedIn() && (resource != null);
    }

    /**
     * @description Grants access to webhook configurations.
     * @path /webhooks/{webhookId}
     * @allow (get, list) All users can read webhook configurations
     * @allow (create, update, delete) All users can create/update/delete webhook configurations.
     * @principle Open access for prototyping.
     */
    match /webhooks/{webhookId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null);
      allow delete: if isSignedIn() && (resource != null);
    }

      /**
       * @description Grants access to roles_admin information.
       * @path /roles_admin/{userId}
       * @allow (get, list) All users can read roles_admin information
       * @allow (create, update, delete) All users can create/update/delete roles_admin information.
       * @principle Open access for prototyping.
       */
    match /roles_admin/{userId} {
       allow get, list: if true;
       allow create: if isSignedIn();
       allow update: if isSignedIn() && (resource != null);
       allow delete: if isSignedIn() && (resource != null);
    }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
  }
}