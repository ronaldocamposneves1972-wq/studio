/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict, path-based ownership model for user data and client-related data.
 *  It uses denormalization to avoid expensive `get()` calls, ensuring authorization independence.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles; only the authenticated user can read/write their own profile.
 * - /roles_admin/{userId}: Indicates admin role via document existence; read-only by anyone to check admin status.
 * - /clients/{clientId}: Stores client information; generally public read, but write access needs to be determined.
 * - /clients/{clientId}/documents/{documentId}: Stores client-uploaded documents; only the associated client can manage these.
 * - /financial_institutions/{financialInstitutionId}, /consortiums/{consortiumId}, /credit_products/{creditProductId}, /product_combos/{productComboId}: Publicly readable product catalogs, write access to be determined.
 * - /sales_proposals/{salesProposalId}: Sales proposals, with denormalized clientId for authorization.
 * - /commissions/{commissionId}, /quizzes/{quizId}, /questions/{questionId}: Data collections where access needs to be determined.
 *
 * Key Security Decisions:
 * - User listing is disabled for privacy.
 * - Read-only collections (e.g., product catalogs) are publicly readable.
 * - All write operations are strictly controlled via `isOwner()` or similar authorization checks.
 * - Authorization Independence: To avoid `get()` calls in security rules, the `clientId` is denormalized within `sales_proposals` to grant access for the specific client.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to manage their own user profile data.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @allow (get, update, delete) Authenticated user can access their own profile.
     * @deny (get, create, update, delete) Any other user attempting to access this profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.auth.uid == userId;
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Determines admin role via document existence.
     * @path /roles_admin/{userId}
     * @allow (get, list) Any authenticated user can check for admin role.
     * @deny (create, update, delete) Only backend services can manage admin roles (not implemented in these rules).
     * @principle Existence over Content. Authorization using /roles_admin/{uid}.
     */
    match /roles_admin/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores client information. Access control needs to be determined (defaulting to owner-only writes).
     * @path /clients/{clientId}
     * @allow (get, list) Anyone can read client information.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Public read access with owner-only writes.
     */
    match /clients/{clientId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores documents uploaded by clients.
     * @path /clients/{clientId}/documents/{documentId}
     * @allow (create) Client with matching ID can create a document.
     * @allow (get, list, update, delete) Authenticated client can access their own documents.
     * @deny (get, create, update, delete) Any other client attempting to access these documents.
     * @principle Enforces document ownership under a client's data tree.
     */
    match /clients/{clientId}/documents/{documentId} {
      function isOwner(clientId) {
        return request.auth.uid == clientId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(clientId);
      allow list: if isSignedIn() && isOwner(clientId);
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isOwner(clientId);
      allow delete: if isSignedIn() && isOwner(clientId);
    }

    /**
     * @description Stores financial institution data. Publicly readable catalog with write access to be determined.
     * @path /financial_institutions/{financialInstitutionId}
     * @allow (get, list) Anyone can read financial institution data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Public read access; write access needs to be defined.
     */
    match /financial_institutions/{financialInstitutionId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores consortium product data. Publicly readable catalog with write access to be determined.
     * @path /consortiums/{consortiumId}
     * @allow (get, list) Anyone can read consortium product data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Public read access; write access needs to be defined.
     */
    match /consortiums/{consortiumId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores credit product data. Publicly readable catalog with write access to be determined.
     * @path /credit_products/{creditProductId}
     * @allow (get, list) Anyone can read credit product data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Public read access; write access needs to be defined.
     */
    match /credit_products/{creditProductId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores product combo data. Publicly readable catalog with write access to be determined.
     * @path /product_combos/{productComboId}
     * @allow (get, list) Anyone can read product combo data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Public read access; write access needs to be defined.
     */
    match /product_combos/{productComboId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores sales proposal data. Includes denormalized 'clientId' for authorization independence.
     * @path /sales_proposals/{salesProposalId}
     * @allow (get) Anyone can read a sales proposal.
     * @allow (list) Only the associated client can list their sales proposals.
     * @deny (create, update, delete) No write access defined yet (TODO).
     * @principle Authorization Independence using denormalized clientId.
     */
    match /sales_proposals/{salesProposalId} {
      function isClient(clientId) {
        return request.auth.uid == clientId;
      }
       function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if isSignedIn() && isClient(request.auth.uid);
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores commission data. Access control needs to be defined.
     * @path /commissions/{commissionId}
     * @allow (get, list) Anyone can read/list commission data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     */
    match /commissions/{commissionId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores quiz data. Access control needs to be defined.
     * @path /quizzes/{quizId}
     * @allow (get, list) Anyone can read/list quiz data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     */
    match /quizzes/{quizId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }

    /**
     * @description Stores question data. Access control needs to be defined.
     * @path /questions/{questionId}
     * @allow (get, list) Anyone can read/list question data.
     * @deny (create, update, delete) No write access defined yet (TODO).
     */
    match /questions/{questionId} {
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Define write access control.
      allow update: if isSignedIn();
      allow delete: if isSignedIn(); // TODO: Define write access control.
    }
  }
}